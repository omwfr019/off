객체지향언어
============
참고서적 : Java의 정석

<br/>

### 객체지향언어의 특징
* 코드의 재사용성이 높음
* 코드의 관리가 용이 (유지보수)
* 신뢰성 높은 프로그래밍 가능 (중복 코드 제거)

<br/>

### 클래스와 객체
* 클래스 : 객체를 정의해 놓은 것. 객체를 생성하는데 사용.
* 객체 : 실제로 존재하는 것. 사물(유형) 또는 개념(무형). 객체가 가지고 있는 기능과 속성에 따라 용도가 다름
* 클래스로부터 객체를 만드는 과정 ~> 클래스의 인스턴스화(instantiate)
* 클래스로부터 만들어진 객체 ~> 클래스의 인스턴스(instance)
* 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 가짐 <br/>
  인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 가짐
* 객체는 속성과 기능의 집합. 객체가 가지고 있는 속성과 기능은 그 객체의 멤버(구성원)
* 속성property : 멤버변수member variable, 특성attribute, 필드field, 상태state <br/>
  기능function : 메서드method, 함수function, 행위behavior
* 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 함
* 참조변수는 인스턴스의 주소를 저장하고 있음
* 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 'Garbage Collector'에 의해 자동적으로 메모리에서 제거됨
* 참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것은 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능ㅎ하지 않음
* 객체 배열
  + 참조변수들을 하나로 묶은 참조변수 배열
  + 객체 배열을 생성하면, 각 요소는 참조변수의 기본값인 null로 자동 초기화되고, 객체의 주소를 저장할 수 있음

#### 클래스
* 객체지향 관점 : 객체를 생성하기 위한 틀. 속성과 기능으로 정의되어 있음
* 프로그래밍적 관점 : 데이터와 함수의 결합
  + 변수 -> 배열 -> 구조체 -> 클래스
    - 변수 : 하나의 데이터를 저장할 수 있는 공간
    - 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
    - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
    - 클래스 : 데이터와 함수의 결합 (구조체+함수)
* 클래스 : 사용자정의 타입
  + 사용자정의 타입(user-defined type) : 프로그래밍 언어에서 제공하는 자료형primitive type외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

<br/>

### 변수variable
* 클래스class 변수 : 클래스 영역 선언. 클래스가 메모리에 올라갈 때 생성. <br/>
  인스턴스 변수 앞에 static을 붙여 선언. 모든 인스턴스가 공통된 저장공간(변수)을 공유 ~> 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 선언 <br/>
  인스턴스를 생성하지 않고 언제라도 바로 사용 가능. '클래스이름.클래스변수' 형식으로 사용 <br/>
  클래스가 메모리에 로딩loading될 때 생성되어 프로그램이 종료될 때 까지 유지 <br/>
  public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수global variable의 성격을 가짐 <br/>
  (참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때, 클래스는 메모리에 로딩됨
* 인스턴스instance 변수 : 클래스 영역 선언. 인스턴스가 생성되었을 때 생성 <br/>
  독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있음 ~> 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우 선언
* 지역변수local : 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)에서 선언. 변수 선언문이 수행되었을 때 생성 <br/>
  메서드 또는 블럭{} 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸 <br/>

* ex) 카드 게임에 사용되는 카드 <br/>
  > class Card { <br/>
  >  static int width = 100;   //폭 <br/>
  >  static int height = 250;  //높이 <br/>
  >  String kind;  //무늬 <br/>
  >  int number;   //숫자 <br/>
  > }

<br/>

### 메서드method
* 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
* 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 몰라도 됨 <br/>
  ~> 메서드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 됨 =black box
* 메서드를 사용하는 이유 : 높은 재사용성reusability, 중복된 코드의 제거, 프로그램의 구조화
* 메서드는 선언부header와 구현부body로 이루어져 있음 <br/>
  메서드를 정의한다 = 선언부와 구현부를 작성한다
* 메서드 선언부 (method declaration, method header)
  + 구성 : '메서드의 이름', '매개변수 선언', '반환타입'
  + 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보 제공
  + 후에 변경사항이 발생하지 않도록 신중히 작성해야 함. 메서드가 호출되는 모든 곳도 같이 변경해야 하기 때문
* 매개변수 선언 (parameter declaration)
  + 매개변수 : 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것
  + 개수 제한은 없지만, 값의 개수가 많은 경우 배열이나 참조변수 이용
  + 매개변수도 메서드 내에 선언된 것으로 간주되므로 지역변수
* 메서드의 이름 (method name)
  + 특정 작업을 수행하므로 동사인 경우가 많음
  + 이름만으로 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓기
* 반환 타입 (return type)
  + 메서드의 작업수행 결과(출력)인 '반환값return value'의 타입을 적음
* 메서드의 구현부 (method body, 메서드 몸통)
  + 메서드의 선언부 다음에 오는 괄호{}
  + 메서드를 호출했을 때 수행될 문장들
* return문
  + 메서드의 반환타입이 void가 아닌 경우, 구현부 안에 'return 반환값;'이 반드시 포함되어야 함
  + 작업을 수행한 결과인 반환값을 호출한 메서드로 전달
  + 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 함
  + 단 하나의 값만 반환 가능
  + return문이 없으면 컴파일 에러(error: missing return statement)가 발생
* 지역변수local variable
  + 메서드 내에 선언된 변수
  + 메서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드라면 같은 이름의 변수를 선언해도 됨
* 호출
  + 메서드를 호출할 때 괄호() 안에 지정해준 값 : 인자argument, 인수
  + 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 함
* 실행흐름
  + 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 호출 가능
  + static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없음
  + 메서드가 호출되면 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행됨 <br/>
    호출된 메서드의 작업이 모두 끝나면, 그 결과를 반환하고 다시 호출한 메서드로 돌아와 이후의 문장들을 실행
* 매개변수의 유효성 검사
  + 매개변수의 값이 적절한 것인지 확인하는 것이 중요. 타입만 맞으면 어떤 값도 매개변수를 통해 넘어올 수 있기 때문에, 가능한 모든 경우의 수에 대해 고민하고 대비해야 함
  + 적절하지 않은 값이 넘어오면 매개변수의 값을 보정하던가, return문을 사용해서 작업을 중단하고 호출한 메서드로 되돌아가야 함

<br/>

### JVM의 메모리 구조
* 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
* 메서드 영역 (method area)
  + 프로그램 실행 중 어떤 클래스가 사용되면 해당 클래스의 클래스파일(\*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장
  + 클래스변수class variable도 이 영역에 함께 생성됨
* 힙 (heap)
  + 인스턴스가 생성되는 공간
  + 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성됨 ~> 인스턴스변수instance variable들이 생성되는 공간
* 호출스택 (call stack, execution stack)
  + 메서드의 작업에 필요한 메모리 공간을 제공
  + 메서드가 호출되면 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용
  + 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워짐
* 각 메서드를 위한 메모리상의 작업공간은 서로 구별됨
  1. 첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련
  2. 첫 번째 메서드 수행 중 다른 메서드를 호출하면, 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간이 마련됨
  3. 이 때 첫 번째 메서드는 수행을 멈추고, 두 번째 메서드가 수행되기 시작
  4. 두 번째로 호출된 메서드가 수행을 마치게 되면, 두 번째 메서드를 위해 제공되었던 호출스택의 메모리공간이 반환
  5. 첫 번째 메서드는 다시 수행을 계속하게 됨
  6. 첫 번째 메서드가 수행을 마치면 메모리 공간이 호출스택에서 제거되며 호출스택은 완전히 비워짐 <br/>
  => 호출스택의 제일 상위에 위치하는 메서드가 현재 실행 중인 메서드이며, 나머지는 대기상태에 있게 됨
* 총정리
  + 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받음
  + 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거됨
  + 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드
  + 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드
  + 반환타입return type이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드caller에게 반환

<br/>

### 기본형 매개변수와 참조형 매개변수
* 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨줌
* 기본형primitive type 매개변수 => 기본형 값이 복사됨. 변수의 값을 읽기만 할 수 있음 (read only) <br/>
  참조형reference type 매개변수 => 인스턴스의 주소가 복사됨. 변수의 값을 읽고 변경할 수 있음 (read & write)
* 참조형 매개변수를 활용하면 반환값이 없어도 메서드의 실행결과를 얻어올 수 있음
* 참조형 반환타입은 메서드가 객체의 주소를 반환

<br/>

### 재귀호출recursive call
* 메서드의 내부에서 메서드 자신을 다시 호출하는 것
+ 메서드 호출은 그저 특정 위치에 저장되어 있는 명령들을 수행하는 것 ~> 메서드 입장에선 자기 자신을 호출하는 것과 다른 메서드를 호출하는 것은 차이가 없음
* 호출된 메서드는 값에 의한 호출call by value을 통해 원래의 값이 아닌 복사된 값으로 작업 ~> 호출한 메서드와 관계없이 독립적인 작업수행 가능
* 반복을 탈출하는 조건문 필수
* 메서드를 호출하는 것은 반복문보다 몇 가지 과정(매개변수 복사, 종료 후 복귀할 주소저장 등)이 추가로 필요하므로 반복문보다 재귀호출의 수행시간이 더 오래 걸림
* 논리적 간결함을 위해 사용 (다소 비효율적이라도 알아보기 쉽게 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고 나중에 수정하기도 좋음) <br/>
  => 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 함
* 대표적인 예 : 팩토리얼factorial

<br/>

### 클래스 메서드(statc 메서드)와 인스턴스 메서드
* 메서드 앞에 static이 붙어 있으면 클래스 메서드, 아니면 인스턴스 메서드
* 클래스 메서드는 '클래스이름.메서드이름(매개변수)'와 같은 식으로 호출 <br/>
  인스턴스 메서드는 반드시 객체를 생성해야만 호출할 수 있음
* 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙임 (공통된 값을 유지)
* 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있음
* 클래스 메서드는 인스턴스 변수를 사용할 수 없음 (클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수 있음) <br/>
  인스턴스 변수나 인스턴스 메서드에선 static이 붙은 멤버들을 사용하는 것이 언제나 가능. 인스턴스 변수가 존재한다는 것은 static 변수가 이미 메모리에 존재한다는 것을 의미
* 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이기 <br/>
  ~> 메서드 호출시간이 짧아지므로 성능이 향상됨 (static을 안 붙인 메서드는 실행 시 호출되어야할 메서드를 찾는 과정이 추가적으로 필요)
* random()과 같은 Math클래스의 메서드는 모두 클래스 메서드. Math클래스에는 인스턴스변수가 하나도 없고, 작업을 수행하는데 필요한 값들을 모두 매개변수로 받아서 처리하기 때문

<br/>

### 오버로딩overloading
* 메서드 오버로딩 : 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것
* 하나의 메서드 이름으로 여러 기능을 구현
* 성립 조건
  + 메서드 이름이 같아야 함
  + 매개변수의 개수 또는 타입이 달라야 함
  + (반환 타입은 오버로딩에 영향 없음)
* 가변인자varargs와 오버로딩
  + 가변인자 : 메서드의 매개변수 개수를 동적으로 지정
  + '타입... 변수명'과 같은 형식으로 선언
  + 가변인자 외에 매개변수가 더 있다면, 가변인자를 매개변수 중에서 제일 마지막에 선언 (가변인자 구별 방법이 없으므로 컴파일 에러 발생)
  + 인자가 없어도 되고 배열도 인자가 될 수 있음
  + 가변인자는 내부적으로 배열을 생성 ~> 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성됨
  + 매개변수의 타입을 배열로 하면 반드시 인자를 지정 (인자 생략 불가) ~> null이나 길이가 0인 배열을 인자로 지정해줘야 함
  + 가변인자를 사용한 메서드는 오버로딩하지 않는 것이 좋음 (구별되지 못하는 경우 발생 확률 높음)
* 예) println메서드

<br/>

### 생성자constructor
* 인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드
* 조건
  + 생성자의 이름은 클래스의 이름과 같아야 함
  + 생성자는 리턴 값이 없음 (void 명시 생략)
* 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아님
* 인스턴스를 생성하는 동시에 원하는 값으로 초기화 가능
* 인스턴스 생성 단계 <br/>
  ex) Card c = new Card();
  1. 연산자 new에 의해 메모리(heap)에 의해 Card클래스의 인스턴스가 생성됨
  2. 생성자 Card()가 호출되어 수행됨
  3. 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장됨 <br/>
  => 클래스이름() = 생성자
* 인스턴스를 생성할 때는 클래스 내에 정의된 생성자 중 하나를 선택하여 지정해야됨
* 기본 생성자default constructor
  + 클래스에 생성자를 정의하지 않고도 인스턴스를 생성할 수 있었던 이유
  + 컴파일 할 때, 소스파일(\*.java)의 <u>클래스에 생성자가 하나도 정의되지 않은 경우</u> 컴파일러는 자동적으로 아래와 같은 내용의 기본 생성자를 추가하여 컴파일
    > 클래스이름() { }
  + 클래스의 접근 제어자가 public인 경우 기본 생성자로 'public 클래스이름() { }'이 추가되어야 함
  + 다른 생성자가 있으면 자동 생성 되지 않음
* 생성자에서 다른 생성자 호출 - this(), this
  + 생성자 간 호출 조건
    - 생성자의 이름으로 클래스이름 대신 this 사용
    - 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출 가능 ~> 초기화 작업도중 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것이므로 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있으므로
* 매개변수와 인스턴스변수 이름이 같을 경우 인스턴스변수 앞에 'this'를 붙임
  + this : 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있음
  + 인스턴스멤버만 사용 가능 (static X)
  + 생성자를 포함한 모든 인스턴스메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 'this'가 지역변수로 숨겨진 채로 존재
  + this(), this(매개변수) : 생성자. 같은 클래스의 다른 생성자를 호출할 때 사용 (this와 다름)

<br/>

### 변수의 초기화
* 변수를 선언하고 처음으로 값을 저장하는 것
* 멤버변수(클래스,인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적
* 멤버변수의 초기화 방법
  + 명시적 초기화explicit initialization
    - 변수를 선언과 동시에 초기화하는 것
    - 여러 초기화 방법 중 가장 우선적으로 고려되어야 함
  + 생성자constructor
  + 초기화 블럭initialization block
    - 클래스/인스턴수 초기화 블럭 : 클래스/인스턴스 변수의 복잡한 초기화에 사용
    - 인스턴스 초기화 블럭 : 클래스 내에 블럭{}을 만들고 그 안에 코드를 작성
    - 클래스 초기화 블럭 : 인스턴스 초기화 블럭 앞에 static을 덧붙임
    - 생성자 보다 인스턴스 초기화 블럭이 먼저 수행됨
  + 인스턴스 변수의 초기화는 주로 생성자 사용. 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행돼야 하는 코드를 넣는데 사용
* 초기화 시기와 순서
  + 클래스 변수의 초기화 시점 : 클래스가 처음 로딩될 때 단 한번 <br/>
    인스턴스 변수의 초기화 시점 : 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어짐
  + 클래스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭 <br/>
    인스턴스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자

<br/>

### 상속
* 기존의 클래스를 재사용하여 새로운 클래스를 작성
* 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드 'extends'와 함께 써줌
* 조상 클래스 : 부모parent 클래스, 상위super 클래스, 기반base 클래스 <br/>
  자손 클래스 : 자식child 클래스, 하위sub 클래스, 파생된derived 클래스
* 자손 클래스는 조상 클래스의 멤버들을 포함 ~> 조상 클래스가 변경되면 자손 클래스에 영향
* 생성자와 초기화 블럭은 상속되지 않음. 멤버만 상속
* 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많음
* 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성됨
* 단일 상속single inheritance
  + 자바에선 다중 상속을 허용하지 않음 (단일 상속만 허용)

#### 포함Composite 관계
* 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것
* ex)
  ``` java
  class Circle {
    int x;  // 원점의 x좌표
    int y;  // 원점의 y좌표
    int r;  // 반지름(radius)
  }
  ```
  를 Point 클래스를 재사용하여 포함관계로 정의하면
  ``` java
  class Circle {
    Point c = new Point();  // 원점
    int r;
  }
  ```
* 클래스를 가지고 문장을 만들었을 때 '~은 ~이다.' (is-a) 라는 문장이 성립한다면 서로 <b/>상속관계</b>를 맺어 주고, <br/>
  '~은 ~을 가지고 있다.' (has-a) 는 문장이 성립한다면 <b>포함관계<b/>를 맺어줌

#### Object 클래스
* 모든 클래스의 조상 (상속계층도 최상위)
* 다른 클래스로부터 상속 받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받음
* 자바의 모든 클래스들은 Object클래스의 멤버들을 상속 받기 때문에 Object클래스에 정의된 멤버들을 사용할 수 있음

### 오버라이딩overriding
* 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
* 상속받은 메서드를 자손 클래스 자신에 맞게 변경해야하는 경우 사용
* 조건 : 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
  + 이름이 같아야 함
  + 매개변수가 같아야 함
  + 반환타입이 같아야 함
  + => 선언부가 서로 일치해야 함
  + 단, 접근 제어자access modifier와 예외 exception는 제한된 조건 하에서만 다르게 변경 가능
* 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경 할 수 없음
  + 조상 클래스에 정의된 메서드의 접근 제어자가 protected라면, 자손 클래스의 메서드는 접근 제어자가 protected나 public이어야 함
  + 대부분 같은 범위의 접근 제어자를 사용
* 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없음
  + 단순히 예외의 개수 X. ex) 조상 클래스가 IOException, SQLException이고, 자손 클래스가 Exception일 경우 Exception은 모든 예외의 최고 조상이므로 가장 많은 개수의 예외를 던질 수 있게 선언한 것이므로 잘못된 오버라이딩
* 인스턴스 메서드를 static 메서드로 또는 그 반대로 변경할 수 없음
* ex) 조상 클래스에 정의된 static 메서드를 자손 클래스에서 똑같은 이름의 static 메서드로 정의 => 가능. 단, 이것은 각 클래스에 별개의 static 메서드를 정의한 것일 뿐 오버라이딩이 아님. '클래스이름.메서드이름()'으로 호출하는 것이 바람직 (static멤버들은 자신들이 정의된 클래스에 묶여있음)

#### 오버로딩 vs 오버라이딩
* 오버로딩 : 기존에 없는 새로운 메서드를 정의 (new)
* 오버라이딩 : 상속받은 메서드의 내용을 변경 (change, modify)

#### super
* 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수
* 상속받은 멤버와 자신의 클래스에 정의된 멤버의 이름이 같을 때 super를 붙여 구별
* super와 this는 근본적으로 같음
* this와 마찬가지로 super 역시 static 메서드에서는 사용 불가. 인스턴스 메서드에서만 사용 가능
* 변수 뿐 아니라 메서드 역시 super를 사용해 호출 가능 (특히 조상 클래스의 메서드를 자손 클래스에서 오버라이딩한 경우)

#### super()
* 조상 클래스의 생성자를 호출하는데 사용
