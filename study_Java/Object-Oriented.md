객체지향언어
============
참고서적 : Java의 정석

<br/>

### 객체지향언어의 특징
* 코드의 재사용성이 높음
* 코드의 관리가 용이 (유지보수)
* 신뢰성 높은 프로그래밍 가능 (중복 코드 제거)

<br/>

### 클래스와 객체
* 클래스 : 객체를 정의해 놓은 것. 객체를 생성하는데 사용.
* 객체 : 실제로 존재하는 것. 사물(유형) 또는 개념(무형). 객체가 가지고 있는 기능과 속성에 따라 용도가 다름
* 클래스로부터 객체를 만드는 과정 ~> 클래스의 인스턴스화(instantiate)
* 클래스로부터 만들어진 객체 ~> 클래스의 인스턴스(instance)
* 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 가짐 <br/>
  인스턴스는 어떤 클래스로부터 만들어진 것인지를 강조하는 보다 구체적인 의미를 가짐
* 객체는 속성과 기능의 집합. 객체가 가지고 있는 속성과 기능은 그 객체의 멤버(구성원)
* 속성property : 멤버변수member variable, 특성attribute, 필드field, 상태state <br/>
  기능function : 메서드method, 함수function, 행위behavior
* 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 함
* 참조변수는 인스턴스의 주소를 저장하고 있음
* 자신을 참조하고 있는 참조변수가 하나도 없는 인스턴스는 더 이상 사용되어질 수 없으므로 'Garbage Collector'에 의해 자동적으로 메모리에서 제거됨
* 참조변수에는 하나의 값(주소)만이 저장될 수 있으므로 둘 이상의 참조변수가 하나의 인스턴스를 가리키는(참조하는) 것은 가능하지만 하나의 참조변수로 여러 개의 인스턴스를 가리키는 것은 가능ㅎ하지 않음
* 객체 배열
  + 참조변수들을 하나로 묶은 참조변수 배열
  + 객체 배열을 생성하면, 각 요소는 참조변수의 기본값인 null로 자동 초기화되고, 객체의 주소를 저장할 수 있음

#### 클래스
* 객체지향 관점 : 객체를 생성하기 위한 틀. 속성과 기능으로 정의되어 있음
* 프로그래밍적 관점 : 데이터와 함수의 결합
  + 변수 -> 배열 -> 구조체 -> 클래스
    - 변수 : 하나의 데이터를 저장할 수 있는 공간
    - 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
    - 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
    - 클래스 : 데이터와 함수의 결합 (구조체+함수)
* 클래스 : 사용자정의 타입
  + 사용자정의 타입(user-defined type) : 프로그래밍 언어에서 제공하는 자료형primitive type외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것

<br/>

### 변수variable
* 클래스class 변수 : 클래스 영역 선언. 클래스가 메모리에 올라갈 때 생성. <br/>
  인스턴스 변수 앞에 static을 붙여 선언. 모든 인스턴스가 공통된 저장공간(변수)을 공유 ~> 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 선언 <br/>
  인스턴스를 생성하지 않고 언제라도 바로 사용 가능. '클래스이름.클래스변수' 형식으로 사용 <br/>
  클래스가 메모리에 로딩loading될 때 생성되어 프로그램이 종료될 때 까지 유지 <br/>
  public을 앞에 붙이면 같은 프로그램 내에서 어디서나 접근할 수 있는 전역변수global variable의 성격을 가짐 <br/>
  (참조변수의 선언이나 객체의 생성과 같이 클래스의 정보가 필요할 때, 클래스는 메모리에 로딩됨
* 인스턴스instance 변수 : 클래스 영역 선언. 인스턴스가 생성되었을 때 생성 <br/>
  독립적인 저장공간을 가지므로 서로 다른 값을 가질 수 있음 ~> 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우 선언
* 지역변수local : 클래스 영역 이외의 영역(메서드, 생성자, 초기화 블럭 내부)에서 선언. 변수 선언문이 수행되었을 때 생성 <br/>
  메서드 또는 블럭{} 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸 <br/>

* ex) 카드 게임에 사용되는 카드 <br/>
  > class Card { <br/>
  >  static int width = 100;   //폭 <br/>
  >  static int height = 250;  //높이 <br/>
  >  String kind;  //무늬 <br/>
  >  int number;   //숫자 <br/>
  > }

<br/>

### 메서드method
* 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
* 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 몰라도 됨 <br/>
  ~> 메서드에 넣을 값(입력)과 반환하는 결과(출력)만 알면 됨 =black box
* 메서드를 사용하는 이유 : 높은 재사용성reusability, 중복된 코드의 제거, 프로그램의 구조화
* 메서드는 선언부header와 구현부body로 이루어져 있음 <br/>
  메서드를 정의한다 = 선언부와 구현부를 작성한다
* 메서드 선언부 (method declaration, method header)
  + 구성 : '메서드의 이름', '매개변수 선언', '반환타입'
  + 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보 제공
  + 후에 변경사항이 발생하지 않도록 신중히 작성해야 함. 메서드가 호출되는 모든 곳도 같이 변경해야 하기 때문
* 매개변수 선언 (parameter declaration)
  + 매개변수 : 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것
  + 개수 제한은 없지만, 값의 개수가 많은 경우 배열이나 참조변수 이용
  + 매개변수도 메서드 내에 선언된 것으로 간주되므로 지역변수
* 메서드의 이름 (method name)
  + 특정 작업을 수행하므로 동사인 경우가 많음
  + 이름만으로 메서드의 기능을 쉽게 알 수 있도록 함축적이면서도 의미있는 이름을 짓기
* 반환 타입 (return type)
  + 메서드의 작업수행 결과(출력)인 '반환값return value'의 타입을 적음
* 메서드의 구현부 (method body, 메서드 몸통)
  + 메서드의 선언부 다음에 오는 괄호{}
  + 메서드를 호출했을 때 수행될 문장들
* return문
  + 메서드의 반환타입이 void가 아닌 경우, 구현부 안에 'return 반환값;'이 반드시 포함되어야 함
  + 작업을 수행한 결과인 반환값을 호출한 메서드로 전달
  + 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 함
  + 단 하나의 값만 반환 가능
  + return문이 없으면 컴파일 에러(error: missing return statement)가 발생
* 지역변수local variable
  + 메서드 내에 선언된 변수
  + 메서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드라면 같은 이름의 변수를 선언해도 됨
* 호출
  + 메서드를 호출할 때 괄호() 안에 지정해준 값 : 인자argument, 인수
  + 인자의 타입은 매개변수의 타입과 일치하거나 자동 형변환이 가능한 것이어야 함
* 실행흐름
  + 같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 호출 가능
  + static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없음
  + 메서드가 호출되면 지금까지 실행 중이던 메서드는 실행을 잠시 멈추고 호출된 메서드의 문장들이 실행됨 <br/>
    호출된 메서드의 작업이 모두 끝나면, 그 결과를 반환하고 다시 호출한 메서드로 돌아와 이후의 문장들을 실행
* 매개변수의 유효성 검사
  + 매개변수의 값이 적절한 것인지 확인하는 것이 중요. 타입만 맞으면 어떤 값도 매개변수를 통해 넘어올 수 있기 때문에, 가능한 모든 경우의 수에 대해 고민하고 대비해야 함
  + 적절하지 않은 값이 넘어오면 매개변수의 값을 보정하던가, return문을 사용해서 작업을 중단하고 호출한 메서드로 되돌아가야 함

<br/>

### JVM의 메모리 구조
* 응용프로그램이 실행되면, JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, 이 메모리를 용도에 따라 여러 영역으로 나누어 관리
* 메서드 영역 (method area)
  + 프로그램 실행 중 어떤 클래스가 사용되면 해당 클래스의 클래스파일(\*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장
  + 클래스변수class variable도 이 영역에 함께 생성됨
* 힙 (heap)
  + 인스턴스가 생성되는 공간
  + 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성됨 ~> 인스턴스변수instance variable들이 생성되는 공간
* 호출스택 (call stack, execution stack)
  + 메서드의 작업에 필요한 메모리 공간을 제공
  + 메서드가 호출되면 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용
  + 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 비워짐
* 각 메서드를 위한 메모리상의 작업공간은 서로 구별됨
  1. 첫 번째로 호출된 메서드를 위한 작업공간이 호출스택의 맨 밑에 마련
  2. 첫 번째 메서드 수행 중 다른 메서드를 호출하면, 첫 번째 메서드의 바로 위에 두 번째로 호출된 메서드를 위한 공간이 마련됨
  3. 이 때 첫 번째 메서드는 수행을 멈추고, 두 번째 메서드가 수행되기 시작
  4. 두 번째로 호출된 메서드가 수행을 마치게 되면, 두 번째 메서드를 위해 제공되었던 호출스택의 메모리공간이 반환
  5. 첫 번째 메서드는 다시 수행을 계속하게 됨
  6. 첫 번째 메서드가 수행을 마치면 메모리 공간이 호출스택에서 제거되며 호출스택은 완전히 비워짐 <br/>
  => 호출스택의 제일 상위에 위치하는 메서드가 현재 실행 중인 메서드이며, 나머지는 대기상태에 있게 됨
* 총정리
  + 메서드가 호출되면 수행에 필요한 만큼의 메모리를 스택에 할당받음
  + 메서드가 수행을 마치고나면 사용했던 메모리를 반환하고 스택에서 제거됨
  + 호출스택의 제일 위에 있는 메서드가 현재 실행 중인 메서드
  + 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드
  + 반환타입return type이 있는 메서드는 종료되면서 결과값을 자신을 호출한 메서드caller에게 반환

<br/>

### 기본형 매개변수와 참조형 매개변수
* 메서드를 호출할 때 매개변수로 지정한 값을 메서드의 매개변수에 복사해서 넘겨줌
* 기본형primitive type 매개변수 => 기본형 값이 복사됨. 변수의 값을 읽기만 할 수 있음 (read only) <br/>
  참조형reference type 매개변수 => 인스턴스의 주소가 복사됨. 변수의 값을 읽고 변경할 수 있음 (read & write)
* 참조형 매개변수를 활용하면 반환값이 없어도 메서드의 실행결과를 얻어올 수 있음
* 참조형 반환타입은 메서드가 객체의 주소를 반환

<br/>

### 재귀호출recursive call
* 메서드의 내부에서 메서드 자신을 다시 호출하는 것
+ 메서드 호출은 그저 특정 위치에 저장되어 있는 명령들을 수행하는 것 ~> 메서드 입장에선 자기 자신을 호출하는 것과 다른 메서드를 호출하는 것은 차이가 없음
* 호출된 메서드는 값에 의한 호출call by value을 통해 원래의 값이 아닌 복사된 값으로 작업 ~> 호출한 메서드와 관계없이 독립적인 작업수행 가능
* 반복을 탈출하는 조건문 필수
* 메서드를 호출하는 것은 반복문보다 몇 가지 과정(매개변수 복사, 종료 후 복귀할 주소저장 등)이 추가로 필요하므로 반복문보다 재귀호출의 수행시간이 더 오래 걸림
* 논리적 간결함을 위해 사용 (다소 비효율적이라도 알아보기 쉽게 작성하는 것이 논리적 오류가 발생할 확률도 줄어들고 나중에 수정하기도 좋음) <br/>
  => 재귀호출에 드는 비용보다 재귀호출의 간결함이 주는 이득이 충분히 큰 경우에만 사용해야 함
* 대표적인 예 : 팩토리얼factorial

