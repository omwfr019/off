JAVA 기초 문법 정리
====================

시작일 : 2021-01-19
참고 서적 : Java의 정


<br/>

### 자바프로그램 실행과정
1. 프로그램의 실행에 필요한 클래스(*.class파일)를 로드한다.
2. 클래스파일을 검사한다.
3. 지정된 클래스(Hello)에서 main(String[] args)를 호출한다.
4. main의 마지막 코드까지 모두 실행되면 프로그램이 종료되고, 프로그램에서 사용했던 자원들은 모두 반환된다.


<br/>

### 변수variable
* 변수를 선언하면, 메모리의 빈 공간에 '변수타입'에 알맞은 크기의 저장공간이 확보되고, 이 저장공간은 '변수이름'을 통해 사용할 수 있다.
* 변수를 사용하기 전 garbage value가 남아있을 수 있으므로 초기화(변수를 사용하기 전에 처음으로 값을 저장하는 것) 필요. (메모리가 공유자원이기 때문) <br/>
  지역변수는 사용되기 전에 초기화를 반드시 해야 하지만, 클래스변수와 인스턴스 변수는 초기화를 생략할 수 있다.
* 식별자 : 프로그래밍에서 사용하는 모든 이름. 같은 영역 내에서 서로 구분될 수 있어야 한다.* 
* 기본형 변수 : 실제 값을 저장
  참조형 변수 : 값이 저장되어 있는 주소를 값으로 가짐
* 참조형 변수 간 연산 불가
* 메모리에는 1 byte 단위로 일련번호가 붙어 있는데, 이 번호가 '메모리 주소'
* 참조형 변수는 null 또는 객체의 주소(4 byte, 8 byte)를 값으로 갖는다. null은 어떤 객체의 주소도 저장되어 있지 않음을 뜻한다.
* 객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소. <br/>
  ex) Date today = new Date(); // Date 객체를 생성해서, 그 주소를 today에 저장
* 정밀도
  + float : 7자리. 32bit, 4byte
  + double : 15자리, 64bit
* 상수(constant) : 한번 값을 저장하면 다른 값으로 변경 불가. 변수 타입 앞에 final 붙여 선언. 반드시 선언과 동시에 초기화 (이후로 값 변경 허용 안됨)
* 리터럴(literal) : 그 자체로 값을 의미. 상수 개념과 동일. <br/>
  + 문자열 리터럴 => 큰 따옴표로 감싸야 함. 여러 문자(문자열)를 저장. ""안에 아무것도 넣지 않는 것 허용.
  + 문자 리터럴 => 작은 따옴표로 문자 하나를 감싸야 함.
  + 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합. <br/>
    ex) 문자열 + any type -> 문자열 + 문자열 -> 문자열
* Scanner - 화면에서 입력받기
  + import java.util.*; // Scanner 클래스를 사용하기 위해 추가
  + Scanner sc = new Scanner(System.in); // Scanner 클래스의 객체를 생성
  + nextLine(), nextInt() 등의 메서드로 입력받기


<br/>

### 진법
* 1 비트bit : 컴퓨터가 값을 저장할 수 있는 최소단위
* 1 바이트byte : 1비트 8개 묶음. 데이터의 기본 데이터 단위
* 워드word : CPU가 한 번에 처리할 수 있는 데이터의 크기. CPU의 성능에 따라 달라짐. ex) 32비트에서 1워드는 4바이트, 64비트에서 1워드는 8바이트
* n비트로 표현할 수 있는 10진수
  + 값의 개수 : 2^n
  + 값의 범위 : 0 ~ 2^n - 1
* (내용 추가 예정)


<br/>

### 기본형primitive type
* 논리형 - boolean
  + true, false 중 하나를 저장할 수 있으며 기본값은 false
  + 크기 : 1 byte
* 문자형 - char
  + 단 하나의 문자만을 저장
  + 실제론 문자가 아닌 '문자의 유니코드(정수)'가 저장됨. ex) 'A' -> 65 저장
  + 특수 문자는 지정된 문자 리터럴로 저장
  + 표현 형식은 정수형과 동일하나, 음수를 나타낼 필요가 없으므로 표현할 수 있는 값의 범위가 다름
* 정수형 - byte, short, int, long
  + 정수형 저장 형식 : 부호 비트(양수는 0, 음수는 1) + 타입의 크기-1 (단위 bit)
  + 첫 번째 비트를 부호 비트sign bit로 사용하고, 나머지는 값을 표현하는데 사용
  + n비트로 표현할 수 있는 정수의 개수 : 2^n개 (= 2^(n-1) + 2^(n-1)개)
  + n비트로 표현할 수 있는 부호있는 정수의 범위 : -2^(n-1) ~ 2^(n-1)-1
  + 기본적으로 int 타입 선언. int의 범위를 넘을 경우 long. byte나 short는 성능보다 저장공간이 중요할 때 사용
  + 오버플로우overflow : 타입이 표현할 수 있는 값의 범위를 넘어서는 것
    - 최대값 + 1 -> 최소값
    - 최소값 -1 -> 최대값
    - 4 bit 2진수의 최소값인 '0000'부터 시작해서 1씩 계속 증가다하 최대값인 '1111'을 넘으면 다시 '0000'. 즉, 값을 무한히 1씩 증가시켜도 '0000'과 '1111'의 범위를 계속 반복
    - 부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생
    - ex) 부호없는 정수의 경우 표현범위가 '0 \~ 15'이므로 이 값이 계속 반복. 부호있는 정수의 경우 '-8 \~ 7'이 무한 반복
* 실수형 - float, double
  + float : 32 bit, 정밀도 7자리 <br/>
    double : 64 bit, 정밀도 15자리
  + 오버플로우가 발생하면 변수의 값은 무한대infinity가 됨
  + 언더플로우 : 실수형으로 표현할 수 없는 아주 작은 값, 즉 양의 최소값보다 작은 값이 되는 경우. 이 때 변수의 값은 0
  + float타입이 아닌 double타입의 변수를 사용하는 경우는 대부분 저장하려는 '값의 범위' 때문이 아니라 '보다 높은 정밀도'가 필요하기 때문
  + 연산속도의 향상이나 메모리를 절약하려면 float, 더 큰 값의 범위라던가 더 높은 정밀도를 필요로 하면 double을 선택
  + 값을 부동소수점수floating-point의 형태로 저장 ~> 실수를 '±M × 2^E' (2의 제곱을 곱한 형태) 와 같은 형태로 표현하는 것. <br/>
    - 부호Sign, 지수Exponent, 가수Mantissa로 이루어짐 <br/>
    - 위 세 부분으로 나누어 저장 (IEEE754 표준)
    - 부호Sign bit : 1 bit. 값이 0이면 양수, 1이면 음수. 2의 보수법을 사용하지 않으므로 음양을 바꾸려면 부호비트만 0->1로 변경하면 됨
    - 지수Exponent : 지수를 저장하는 부분. float의 경우 8bit. 부호있는 정수. '-127~128'의 값이 저장되지만 -127과 128은 숫자 아님NaN이나 양의 무한대POSITIVE_INFINITY, 음의 무한대NEGATIVE_INFINITY와 같은 특별값을 위해 예약되어 있으므로 실제 사용가능 범위는 '-126\~127'
    - 가수Mantissa : 실제 값인 가수를 저장하는 부분. float의 경우 2진수 23자리를 저장할 수 있음 ~> 약 7자리 10진수 저장 가능 = 정밀도. double이 float보다 약 2배의 정밀도를 가짐
    - 부동소수점의 오차 : 무한소수가 존재하므로 오차가 발생할 수 있음. 2진수로 변환하면 무한소수가 되는 경우 있음. 2진수로 변환된 실수를 저장할 대는 먼저 '1.xxx X 2^n'의 형태로 변환하는데, 이 과정을 정규화라고 함.
    - 지수는 기저법으로 저장 : '2의 보수법'처럼 부호있는 정수를 저장하는 방법. 저장할 때 특정값(기저)을 더했다가 읽어올 때는 다시 뺌
* 인코딩encoding & 디코딩decoding
  + 문자 인코딩encoding : 문자를 코드로 변환하는 것. 문자를 저장할 때 인코딩하여 숫자로 변환해서 저장 <br/>
    문자 디코딩decoding : 코드를 문자로 변환하는 것. 저장된 문자를 읽어올 때 디코딩을 해서 숫자를 원래의 문자로 되돌림
  + 문자-숫자의 변환 기준은 유니코드


<br/>

### 형변환casting
* 변수나 리터럴의 타입을 다른 타입으로 변환하는 것
* 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호(캐스팅 연산자)와 함께 붙여줌 <br/>
  형변환 연산자 => 피연산자의 값을 읽어 지정된 타입으로 형변환하고 그 결과를 반환
* 기본형에서 boolean을 제외한 나머지 타입들은 서로 형변환 가능. 기본형과 참조형간의 형변환은 불가능
* 실수형 -> 정수형 형변환 시 소수점 이하 값은 버려짐
* 정수형간의 형변환
  + 큰 타입 -> 작은 타입 : 크기의 차이만큼 잘려나감. 값 손실loss of data 발생
  + 작은 타입 -> 큰 타입 : 값 손실 없음. 빈공간은 0 또는 1로 채워짐 (0이 보통이지만, 변환하려는 값이 음수이면 1로 채움 ~> 부호 유지)
* 실수형간의 형변환
  + 작은 타입 -> 큰 타입 : 빈 공간을 0으로 채움
  + float -> double : 지수E는 float의 기저인 127을 뺀 후 double의 기저인 1023을 더해서 변환하고, 가수M는 float의 가수 23자리를 채우고 남은 자리를 0으로 채움
  + double -> float : 지수E는 double의 기저인 1023을 뺀 후 float의 기저인 127을 더하고, 가수M는 double의 가수 52자리 중 23자리만 저장되고 나머지는 버려짐 <br/>
    주의할 점은 가수의 24번재 자리에서 반올림이 발생할 수 있다는 것. 24번째 자리의 값이 1이면, 반올림이 발생하여 23번째 자리의 값이 1 증가 <br/>
    float타입의 범위를 넘는 값을 float로 형변환하는 경우 ±무한대 또는 ±0을 결과로 얻음
  + 정수형과 실수형 간의 형변환
    - 정수 -> 실수 : 정수를 2진수로 변환한 다음 정규화를 거쳐 실수의 저장형식으로 저장
    - 실수 -> 정수 : 소수점 이하 값이 버려짐. 반올림 발생 안함. 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우 정수의 오버플로우가 발생한 결과를 얻음. <br/>
      ex) 1.666 -> 1
  + 자동 형변환
    - 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생 <br/>
      "incompatible types: possible lossy conversion from int to byte" ~> 큰 타입에서 작은 타입으로의 형변환은 값 손실이 발생할 수 있음
    - 명시적으로 형변환 할 경우 의도적인 것으로 간주하고 에러를 발생시키지 않음
    - 산술 변환 : 연산과정에서 자동적으로 발생하는 형변환
    - 기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환됨 (표현범위가 더 넓은 쪽으로) <br/>
      byte -> short, char -> int -> long -> float -> double <br/>
      (char, short은 크기는 같지만 범위가 달라 서로 자동 형변환이 수행될 수 없음)


<br/>

### 연산자operator
* 우선순위 
  + 산술 > 비교 > 논리 > 대입
  + 단항 > 이항 > 삼항
  + 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼->오
* 산술 변환usual arithmetic conversion
  + 연산 전에 피연산자의 타입의 일치를 위해 자동 형변환되는 것
  + 이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 형변환 연산자로 타입을 일치시킴
  + 두 피연산자의 타입 중 더 큰 타입으로 일치시킴 (값 손실 방지). ex) float + int -> float + float -> float
  + 피연산자의 타입이 int보다 작은 타입이면 int로 변환. ex) char + short -> int + int -> int <br/>
    ``` java
    byte a = 10;
    byte b = 10;
    byte c = a + b; //컴파일 에러 발생. 명시적 형변환 필요. byte c = (byte)(a+b);
    ```
  + 단항 연산자에서도 일어남
* 부호 연산자 + -
  + 부호 연산자 '-'는 피연산자의 부호를 반대로 변경한 결과를 반환
  + boolean, char형을 제외한 기본형에서만 사용 가능
* 사칙 연산자
  + 나누는 연산자의 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int 타입 <br/>
    ~> 소수점을 저장하지 못하므로 정수만 남고 소수점 이하는 버려짐. 반올림 발생 안함. ex) 10/4->2 <br/>
    => 올바른 연산결과를 얻기 위해서는 두 피연산자 중 어느 한 쪽을 실수형으로 형변환
    ``` java
    int a = 1_000_000;
    int b = 2_000_000;
    long c = a * b; // 실행결과 -1454759936
                    // a*b의 결과가 이미 int타입의 값이므로 long형으로 자동 형변환되어도 값이 변하지 않음
                    // 올바른 결과를 원할 경우 long c= (long)a * b;
    ```
  + 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없음 (컴파일은 정상, 실행 오류 ArithmeticException 발생) <br/>
    부동 소수점값인 0.0f, 0.0d로 나누는 것은 가능하지만 결과는 Infinity
  + 순서에 따른 결과
    ``` java
    int a = 1000000;
    
    int result1 = a * a / a; //-727
                             // int * int -> int에서 이미 오버플로우 발생
    int result2 = a / a * a; //1000000
    ```
* 문자 연산
  + 사칙 연산의 피연산자로 문자도 가능 ~> 문자는 실제로 유니코드(부호없는 정수)로 바뀌어 저장되므로 문자간의 사칙연산은 정수간의 연산과 동일
  + 문자를 숫자로 변환하려면 문자 '0'을 빼주면 됨. ex) '2'-'0' -> 50-48 -> 2 (문자 '0'은 유니코드 48)
  + 컴파일러 시점에 따른 결과
    ``` java
    char c1 = 'a';
    char c2 = c1 + 1; // 컴파일 에러발생 ~> c1+1의 결과는 int형이므로 (char)(c1+1); 또는 c1++; 으로 써야함
                      // 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산을 할 수 없으므로 명시적 형변환 필요
    char c2 = 'a' + 1;  // 실행결과 : b
                        // 'a'+1은 리터럴 간의 연산. 리터럴 간 연산은 실행 과정동안 변하는 값이 아니기 때문에 컴파일 시에 컴파일러가 미리 계산해서 그 결과로 대체 (실행 시에는 덧셈 연산이 수행되지 않음. 그저 결과인 문자 'b'를 변수 c2에 저장할 뿐)
    ```
    - 컴파일 전의 코드 : char c2 = 'a'+1; int sec = 60*60*24;
    - 컴파일 후의 코드 : char c2 = 'b'; int sec = 86400;
* 나머지 연산자 %
  + 나누는 수로 0을 사용할 수 없고, 피연산자로 정수만 허용.
  + 주로 짝수, 홀수, 배수 검사 등에 사용
  + 나누는 수로 음수를 허용하지만 부호는 무시됨 ~> 결과는 음수의 절대값으로 나눈 나머지와 같다
* 비교 연산자
  + 비교하는 피연산자의 타입이 서로 다를 경우 자료형의 범위가 큰 쪽으로 자동 형변환
  + 대소비교 연산자는 참조형에 사용할 수 없음
  + 등가비교 연산자는 모든 자료형에 사용 가능. 기본형의 경우 변수에 저장되어 있는 값이 같은지, 참조형의 경우 두 개의 피연산자가 같은 객체를 가리키고 있는지.
  + 정수형, 실수형
    ex) 10.0==10.0f는 true인데 0.1==0.1f는 false => 실수형은 근사값으로 저장되므로 오차가 발생할 수 있기 때문 <br/>
    => float와 double타입 값의 비교는 double 타입의 값을 float 타입으로 형변환한 다음에 비교해야 함
* 비트 연산자 & | ^ ~ << >>
  + 피연산자를 비트단위로 논리 연산
  + 피연산자로 실수는 허용하지 않음. 문자 포함 정수만 허용
  + | (OR연산자) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과를 얻는다. 그 외에는 0을 얻는다. <br/>
    & (AND연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다. <br/>
    ^ (XOR연산자) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
  + 비트OR연산자 '|'는 주로 특정 비트의 값을 변경할 때 사용 <br/>
    비트AND연산자 '&'는 주로 특정 비트의 값을 뽑아낼 때 사용 <br/>
    비트XOR연산자 '^'는 간단한 암호화에 사용. XOR 연산 후 같은 값으로 두고 XOR 연산을 수행하면 원래의 값으로 돌아옴
  + 피연산자의 타입을 일치시키는 '산술 변환'이 일어날 수 있음
  + (내용 추가 예정)


<br/>

### 조건문, 반복문
* 제어문control statement : 프로그램의 흐름flow을 바꾸는 역할을 하는 문장들
* for, while문에 속한 문장은 한 번도 수행되지 않을 수 있지만, do-while문은 최소한 한 번은 수행 보장




### 기타
* 주석 (/** ~ */)은 Java API 문서와 같은 형식의 문서를 자동으로 만들 수 있음. javadoc.exe에 의해 html 문서로 자동 변환됨.
* 난수 발생 : 0.0 <= Math.random() < 1.0 범위에 속하는 하나의 double 값을 반환

