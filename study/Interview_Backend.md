Back-end Developer Interview Questions
=======================================
<br>

#### 1. JAVA
> JVM에 의해 가동되어 운영 체제에 독립적인 프로그래밍 언어입니다. 클래스를 기반으로 한 객체 지향 언어이기 때문에 기본 자료형을 제외한 요소들이 객체로 표현되고, 각 객체가 필요한 시점에 클래스를 동적 로딩해서 사용합니다.
<br/>

#### 2. OOP
> 객체 지향 프로그래밍 Object-oriented Programming.  <br/>
객체 지향은 절차 지향과 다르게 객체 간의 상호작용을 통해 프로그램이 동작합니다.  <br/>
즉, 객체 지향 프로그래밍은 데이터나 그 데이터에 관련된 동작을 객체로 취급하고, 그 객체들을 연결시켜 프로그래밍 하는 것입니다. 사람의 사고방식과 가깝게 현실 세계를 모델링하여 컴퓨터에 구현할 수 있습니다.
<br/>

#### 3. OOP의 특징 4가지
> 추상화, 캡슐화, 상속성, 다형성.  <br/>  
추상화란 공통의 속성이나 행위를 묶어 조합하고, 이에 대한 필수 정보만을 추출하는 것입니다. 세부 사항을 줄여 관계없는 부분을 축소하고, 필요한 정보만을 묶어 구성할 수 있기 때문에 공통된 개념과 관계를 바탕으로 개발이 가능합니다. 추상 클래스나 인터페이스를 이용해 정의합니다.  <br/>  
캡슐화란 목적을 가진 클래스 안에 관련 있는 변수나 함수를 정의하고, 이 클래스에 접근할 때 제공된 함스를 통해서만 접근할 수 있게 하는 것입니다. 내부 정보를 은닉하고 객체가 손상되는 것을 막아줍니다. 접근 제한자를 통해 설정하고, 게터/세터로 읽고 쓸 수 있습니다.  <br/>  
상속성이란 상위 클래스의 특성을 재사용하고, 하위 클래스에서 필요한 속성을 확장하여 사용하는 것입니다. 반복된 코드의 중복을 줄이고, 유지 보수의 편리성을 제공합니다.  <br/>  
다형성은 상속을 받은 기능을 확장하여 하나의 클래스나 함수가 다양한 방식으로 동작하는 것입니다. 하나의 지시에 각각 다른 기능을 수행하게 되어 다양한 실행 결과를 얻을 수 있습니다. 객체를 부품화하여 유지 보수를 용이하게 한다는 장점이 있고, 오버로딩이나 오버라이딩을 통해 구현합니다.
<br/>

#### 4. 오버라이딩과 오버로딩
> 오버라이딩은 슈퍼클래스를 상속받은 서브 클래스에서 슈퍼 클래스의 메소드를 같은 이름, 같은 반환 값, 같은 인자로 메소드 내 로직을 새롭게 정의하는 것입니다. 같은 이름이지만 다른 역할을 하는 클래스를 만들 수 있습니다.  <br/>  
오버로딩은 한 클래스 내에서 같은 이름의 메소드를 여러 개 갖는 것입니다. 유사한 일을 수행하며 인자나 반환 타입만 다른 메소드를 만들 수 있습니다. 조건은 메소드 인자의 수나 자료형이 달라야 한다는 것입니다.
<br/>

#### 5. 클래스, 객체, 인스턴스
> 객체object는 소프트웨어에 구현할 대상을 말합니다. 클래스의 타입으로 선언된 모든 것을 객체라 부를 수 있습니다.  <br/>  
클래스class는 연관되어 있는 변수와 메소드의 집합으로, 객체를 만들어내기 위한 설계도라고 볼 수 있습니다.  <br/>  
이 클래스로 소프트웨어에 구현된 실체가 인스턴스instance입니다. 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부를 수 있습니다.  <br/>    
인스턴스가 어떤 원본으로부터 생성되었다는 의미가 내포되어 있어 복제본과 유사하다면, 객체는 그 실체를 가리키는 것에 가깝습니다.
객체와 인스턴스를 정확히 나누는 기준은 없으므로 실체와 관계 중 어디에 중점을 두었느냐로 구별하여 사용합니다.
<br/>    

#### 6. 추상 클래스와 인터페이스
> 추상 클래스는 abstract로 선언하며, 한 개 이상의 추상 메소드를 가진 클래스입니다. 추상 클래스를 상속받은 하위 클래스에게 슈퍼 클래스의 모든 추상 메소드를 오버라이딩으로 구현할 것을 강제합니다. 자신의 생성자로 객체 생성이 불가하기 때문에, 추상 클래스는 객체 생성이 아닌, 상속을 통한 부모 클래스 확장이 목적이라 볼 수 있습니다.  <br/>  
인터페이스란 interface 키워드를 사용해 선언하며, 추상 메소드(abstract public)와 상수(public static final)만을 포함할 수 있습니다. 즉, 구현부가 없는 메소드입니다. 인터페이스를 구현하는 클래스는 반드시 인터페이스의 추상메소드를 모두 구현해야 합니다. 따라서 구현 객체의 같은 동작을 보장합니다.  <br/>  
단, JAVA8부터 추상 메소드 뿐만 아니라 디폴트default 메소드와 정적static 메소드도 추가 선언이 가능해졌습니다. 내부 메소드에 static을 사용하면 객체 없이 인터페이스만으로 호출이 가능하며 재정의가 불가능합니다. default는 인터페이스 내에서 직접 메서드를 구현한다는 의미의 접근 제어자입니다. 구현받은 클래스는 오버라이딩 없이 default 메서드를 사용할 수 있습니다 (오버라이딩도 가능).
<br/>

#### 7. 접근제한자
> 클래스의 멤버 변수 또는 메소드에 설정하는 키워드로, 접근 영역을 제한하는 데 사용합니다.  <br/>
public은 제한을 두지 않을 때, protected는 같은 패키지나 다른 패키지에서 상속을 받아 접근할 때, default는 같은 패키지 내에서만, private은 같은 클래스 내에서만 접근이 가능합니다.
<br/>

#### 8. static
> 클래스가 메모리에 올라갈 때 공간을 할당하여 처음 생성된 메모리 공간을 변하지 않게 합니다. 인스턴스를 생성하지 않아도 사용할 수 있고, 객체를 여러 개 생성해도 해당 변수는 하나만 존재하기 때문에 모든 인스턴스에 공통으로 사용되어야 하는 것에 붙이는 키워드입니다. 주의할 점은 static이 만들어진 시점에서 인스턴스 변수의 생성 여부는 보장되지 않으므로, static 메서드에서는 인스턴스 변수를 사용할 수 없다는 것입니다.
<br/>

#### 9. final
> 상수를 만드는 키워드입니다. 값을 한 번만 할당하고, 두 번 이상 할당하면 컴파일 오류가 발생합니다. 변수의 값을 변경할 수 없고, 메소드의 오버라이드나 클래스의 상속, 확장, 변경이 불가합니다. 대표적인 final class엔 String이 있습니다.
<br/>

#### 10. 강한 참조, 약한 참조
> 강한 참조는 new 키워드를 통해 객체를 생성합니다. 강한 참조를 통해 참조되고 있는 개체는 루트와의 접근성을 체크해 연결이 유지되고 있으면(=참조되고 있으면) GC의 대상에서 제외됩니다.  <br/>  
약한 참조는 GC가 발생하면 무조건 수거되며, 짧은 주기에 자주 사용되는 객체를 캐시할 때 유용합니다.
<br/>

#### 11. 깊은 복사, 얕은 복사
> 얕은 복사는 해당 객체만 복사하여 새 객체를 생성하고, 깊은 복사는 해당 객체와 인스턴스 변수까지 복사하는 형태입니다.  <br/>  
기본 자료형 변수는 값이 그대로 복사됩니다. 예를 들어, 파라미터를 전달할 때에도 생성되는 메모리의 위치가 다르기 때문에 값이 복사되어 전달되며, 따라서 파라미터를 전달받은 메소드 안에서 수정이 발생해도 원본이 변하지 않습니다. 이러한 값 복사를 깊은 복사라고 합니다.  <br/>  
얇은 복사는 참조 복사의 의미이며, 값을 수정하면 복사본과 원본이 함께 바뀝니다. 변수가 가리키는 위치에 저장되어 있는 주소 자체가 복사되기 때문입니다.
<br/>

#### 12. Call by Value와 Call by Reference
> call by value는 값에 의한 호출로, 함수가 호출될 때 메모리 공간 안에서 함수를 위한 별도의 임시 공간이 생성됩니다. 인자로 전달되는 변수의 값이 복사되므로 복사된 인자는 지역 변수의 특징을 가집니다. 즉, 함수 안에서 값이 변경되어도 외부 변수의 값은 변경되지 않습니다.  <br/>  
call by reference는 참조에 의한 호출로, 기본 데이터형을 제외한 배열이나 클래스 객체를 인수로 전달한 경우 값이 아닌 참조 주소를 전달합니다. 따라서 함수 안에서 값이 변경되면 인자로 전달된 변수의 값도 함께 변경됩니다.  <br/>  
자바는 call by value로 동작합니다. 참조형 타입을 인자로 넘겨도 그 값의 레퍼런스가 복사되어 넘겨지게 됩니다.
<br/>

#### 13. OOP의 5대 원칙 (SOLID)
> 객체는 단 하나의 책임(기능)만 져야 한다는 '단일 책임 원칙(Single Responsibility Principle)'.  <br/>
기존의 코드를 변경하지 않고 기능을 수정, 추가할 수 있도록 설계하는 '개방-폐쇄 원칙(Open Closed Principle)'.  <br/>
자식 클래스는 부모 클래스에서 가능한 행위를 수행할 수 있어야 한다는 '리스코프 치환 원칙(Liskov Substitution Principle)'.  <br/>
의존 관계를 맺을 때 변화하기 쉬운 것 보단 변화하기 어려운 것에 의존해야 한다는 '의존 역전 원칙(Dependency Inversion Principle)'.  <br/>
인터페이스를 클라이언트에 특화되도록 분리해야 하는 '인터페이스 분리 원칙(Interface Segregation Principle)'.
<br/>

#### 14. 기본 자료형과 참조 자료형
> 기본 자료형에는 byte, short, int, long, float, double, char, boolean 이 있습니다. 사용하기 전에 선언되어야 하며, 변수의 실제 값을 가지고 있습니다.  <br/>  
참조형은 String, 배열, 클래스, 인터페이스 등 기본 자료형을 제외한 모든 것을 뜻하며, java.lang.Object를 상속받으면 참조형이라 볼 수 있습니다. 값이 아닌 객체의 주소를 갖고 있습니다.
<br/>

#### 15. 추상화와 캡슐화의 차이점
> 서로 보완적인 개념을 가지고 있습니다. 추상화는 객체의 동작에 집중하여 관련 없는 부분을 제거해 필수적인 요소만 남기는 것이고, 캡슐화는 추상화된 구체적인 내부 정보가 노출되지 않도록 은닉하는 것입니다. 즉, 추상화는 원하는 데이터를 숨기기 위해, 캡슐화는 외부 세계로부터 데이터를 보호하기 위해 그룹화된 정보를 숨기는 데 사용합니다.
<br/>

#### 16. 정보 은닉의 종류
> 상위 타입 캐스팅을 이용한 객체의 구체적인 '타입 은닉', 캡슐화라고 불리는 객체의 '필드 및 메소드 은닉', 인터페이스 및 추상 클래스 기반 구현을 통한 '구현 은닉'이 있습니다.
<br/>

#### 17. JVM
> Java Virtual Machine의 약자로, java 바이트 코드를 실행할 수 있는 가상 머신입니다. 모든 플랫폼에서 실행될 수 있는 응용 프로그램을 빌드합니다.  <br/>
JVM의 서브시스템은 런타임시점에 클래스파일을 메모리에 적재(로딩)시키는 '클래스 로더Class Loader', 메모리의 각 영역을 관리하는 '실행 데이터 영역Runtime Data Access', 실행을 돕는 '실행 엔진Execution Engine'으로 이루어져 있습니다.  <br/>
동작 과정은, 컴파일러로 .java 소스 파일을 컴파일하여 .class 파일로 만들고, JVM에게 건네주면, JVM이 클래스 파일을 메모리에 로드하며 실행하게 됩니다.
<br/>

#### 18. JDK과 JRE의 차이점
> JRE는 Java Runtime Environment의 약자로, JVM을 생성하는 디스크 상의 부분이자 JDK의 일부입니다 (프로그램 구동이 개발의 일환이기 때문). 자바 코드를 실행할 때 필요한 라이브러리 파일과 도구들을 가지고 있습니다. (개발이 아닌 실행만 할 경우 JRE를 설치하면 됨)  <br/>  
JDK는 Java Development Kit의 약자로, JAVA 용 소프트웨어 개발 키트입니다. Java 으용 프로그램을 개발, 컴파일, 실행할 수 있도록 JRE, 컴파일러, 기타 도구(JavaDoc, Java 디버거 등)를 포함한 기능의 모음이라고 볼 수 있습니다. 여기서 컴파일러란, 원시 .java 파일을 받아 실행 가능한 .class 파일로 만드는 소프트웨어입니다.  <br/>  
JDK(개발자용) = JRE + Development Tools  <br/>
JRE(사용자용) = JVM(가상머신) + Library Classes
<br/>

#### 19. JAVA SE와 JAVA EE의 차이점
> JDK의 패키지로, SE는 표준 에디션, EE는 엔터프라이즈 자바 빈이나 객체 관계 매핑Object Relational Mapping 지원 값은 기업용 애플리케이션 개발에 유용한 추가적인 도구들을 가지고 있는 플랫폼입니다. 서버 측 개발에 적합합니다.
<br/>

#### 20. IDE
> 통합 개발 환경Integrated Development Environment.  <br/>
코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 관련된 모든 작업을 하나의 프로그램 안에서 처리하는 환경을 제공하는 소프트웨어입니다. 개발자의 코딩을 쉽게 도와주는 작업기라고 볼 수 있습니다.  <br/>
이클립스, 비주얼 스튜디오, 비주얼 스튜디오 코드 등이 있습니다.
<br/>

#### 21. API
> Application Programming Interface의 약자로, JAVA에서 기본으로 제공하는 클래스 라이브러리 집합입니다. 개발에 필요한 클래스들을 미리 구현하여 사용자가 쉽게 개발할 수 있도록 돕는 역할을 합니다. 패키지로 제공되며, 하나의 커다란 클래스 계층 구조로 설계되어 있습니다. 대표적으로 lang, util, io 등이 있습니다.  <br/>
ex) 수학 연산자 사용을 위해 import하는 java.lang.Math
<br/>

#### 22. JVM 클래스 로더 시스템
> 동적 클래스를 로딩해 상속 관계로 정의하고, 위임 방식으로 작업을 진행합니다. 크게 로디-연결-초기화로 나눌 수 있습니다.
<br/>

#### 23. JVM 실행 데이터 영역
> 메소드 영역은 모든 클래스 수준, 즉, 클래스명, 부모 클래스명, 메소드, 변수의 데이터가 저장됩니다. JVM에 하나만 존재하며, 멀티스레드 접근이 가능한 공유 자원입니다.  <br/>  
힙 영역은 클래스나 배열과 같은 모든 인스턴스 오브젝트가 저장되고, JVM 당 하나만 존재하는 공유자원입니다. 사용자가 직접 동적 할당/해제를 할 수 있는 메모리이기도 합니다.  <br/>  
스택 영역은 각각의 스레드마다 개별 영역으로 존재합니다. 메소드 콜스택이 호출될 때마다 스택 프레임이라는 메모리 영역에 쌓이며, 호출과 동시에 할당되고 종료 시 해제됩니다. 모든 지역변수가 저장되는 곳이고, 공유 자원이 아니므로 스레드에 안전합니다.  <br/>  
PC 레지스터는 현재 실행 중인 명령문의 주소를 가지기 위해 각각의 스레드마다 개별적으로 존재합니다.  <br/>  
네이티브 메소드 스택은 native 메소드 정보를 가지고 있는 스택으로, 개별 스레드마다 생성됩니다.
<br/>

#### 24. JVM 실행 엔진
> 실행 데이터 영역에서 할당된 바이트 코드를 조각 단위별로 읽어 들여 실행합니다. 기본적으로 인터프리터가 바이트 코드를 해석하지만, 하나의 메소드가 여러 번 호출되면 매번 새로운 해석이 필요한데, 이를 보완하기 위해 JIT(Just-In-Time) 컴파일러가 동작합니다. 반복되는 부분을 원시native 코드로 컴파일하고, 변환된 원시 코드는 인터프리터를 거치지 않고 직접 사용이 가능합니다. 그 외엔 Garbage Collector가 생성된 인스턴스를 모아 참조가 없는 인스턴스를 제거합니다.
<br/>

#### 25. 자바의 바이트코드
> 자바의 플랫폼 독립적이라는 특징과 관련이 있습니다. .java 코드를 컴파일하면 바이트 코드(.class) 형태로 출력되며, 이 형태는 JVM에 의해 런타임 시 기계 코드로 변환되어 실행이 가능해집니다.
<br/>

#### 26. 자바의 IO(Input-Output) 처리 과정
> 먼저, 유저 영역에 위치한 프로세스가 커널에 파일 읽기 명령을 내립니다. 커널은 시스템 콜(read())을 사용해 디스크 컨트롤러가 물리적 디스크로부터 읽어온 파일 데이터를 커널 영역 안의 버퍼에 사용합니다. 모든 파일 데이터가 버퍼에 복사되면 다시 프로세스 안의 버퍼로 복사하고, 프로세스 안 버퍼의 내용으로 프로그래밍하게 됩니다. IO 프로세스를 거치는 동안 작업을 요청한 스레드는 blocking 됩니다.
<br/>

#### 27. NIO
> 새롭게 등장한 IO 처리 과정으로, 기존 IO와 다르게 실제 IO가 발생한 채널만 스레드를 생성해 관리합니다. 따라서 blocking과 context switching 현상을 방지할 수 있습니다.  <br/>
기존 IO는 커널 영역의 데이터를 유저 영역의 버퍼로 복사하는 비효율적인 과정을 거치는데, NIO는 유저 영역의 버퍼와 커널 영역의 버퍼가 같은 물리 메모리를 참조하도록 매핑(memory-mapped IO) 시켜 복사의 과정을 생략합니다. 따라서 별도의 입출력 과정 없이 디스크에 반영할 수 있습니다.  <br/>
즉, 기존의 스트림 방식이 아닌 채널 방식(양방향 입출력 클래스)을 이용하고, 버퍼 사용, 블로킹/논블로킹을 모두 사용할 수 있는 입출력 방식입니다.  <br/>
연결 클라이언트 수가 많고, 하나의 입출력 처리 작업이 오래 걸리지 않는 경우 사용하는 것이 좋습니다.
<br/>

#### 28. Context Switching
> CPU가 한 개의 task를 실행하고 있는 상태일 때, interrupt 요청에 의해 다른 task로 실행이 전환되는 과정에서 기존의 task 상태 및 레지스터 값들에 대한 정보를 저장하고 새로운 task의 context로 교차하는 작업입니다.  <br/>
현재 실행하고 있는 task의 PCB 정보를 저장하고, 다음 task의 PCB 정보를 읽어 레지스터에 적재합니다. 이러한 대기, 실행 과정을 반복하며 CPU가 이전에 진행했던 과정을 연속적으로 수행하게 되는 것입니다.  <br/>
여기서 PCB란 프로세스의 정보를 저장하는 블록으로, 프로세스가 생성되면 메모리에 함께 생성됩니다.  <br/>
컨텍스트 스위칭은 스케줄러에 의해 관리됩니다.
<br/>

#### 29. 프로세스와 스케줄링
> 프로세스란 실행 파일을 클릭했을 때, 메모리Ram 할당이 이루어지고 이 공간으로 코드가 올라가게 됩니다. 이러한 실행 중인 프로그램을 '프로세스'라고 합니다.  <br/>  
멀티프로세스 운영체제에서 CPU가 여러 개의 프로세스의 순서와 방법을 결정해 할당하는 것을 스케줄링이라고 합니다. 실제로 한 개의 프로세스를 실행하고 있지만 매우 고속이기에 동시에 실행되는 것처럼 보입니다.  <br/>  
자식 프로세스는 부모 프로세스를 상속하지만, 각 영역은 독립적으로 만들어집니다. 따라서 데이터를 주고받기 위해서는 IPC(Inter Process Communication)가 필요하지만, 스레드를 생성하는 경우 공유하는 영역이 생기게 됩니다. 따라서 프로세스에서의 스위칭보다 빠르게 컨텍스트 스위칭이 가능합니다.  <br/>
또한, 캐시에 의한 속도 차이도 있습니다. 캐시는 CPU와 메인메모리 사이에 위치하며, CPU에서 한 번 이상 읽어 들인 메모리의 데이터를 저장하고 있다가, CPU가 다시 데이터를 요구할 때 메인메모리를 통하지 않고 데이터를 전달해 줍니다. 프로세스 컨텍스트 스위칭은 공유 데이터가 없으므로 캐시 정보를 새로 만들어야 하기에 속도가 느립니다.  <br/>
프로세스는 ready, running, blocked의 세 가지 상태를 지니고, running과 ready는 우선순위에 따라 상태가 결정됩니다. blocked는 스케줄러에 의해 선택이 되지 않는 프로세스를 말합니다.
<br/>

#### 30. 오버헤드overhead
> 특정 처리를 위해 추가로 들어간 컴퓨터의 자원(처리 시간, 메모리)으로, 목적 달성에 본질적인 것은 아니지만 간접적으로 필요한 자원을 뜻합니다.
<br/>

#### 31. 블로킹blockig과 논블로킹non-blocking
> 블로킹이란, 시스템 콜을 호출했을 때 동작이 완료될 때까지 모든 작업을 중단한 상태로 대기하는 방식으로, 해당 시스템 콜에서 프로세스가 멈춰있는 상태입니다.  <br/>  
논블로킹은 반대 개념으로, 처리가 끝나지 않아도 시스템 콜이 바로 리턴되어 병행 작업을 수행할 수 있습니다.  <br/>
논블로킹 모드에서 어떤 시스템 콜이 성공적으로 실행될 때까지 계속 루프를 돌며 확인하는 방법을 폴링polling이라고 합니다.
<br/>

#### 32. 비동기Asynchronous와 동기Synchronous
> 비동기란 요청을 보내면 바로 결과(제어권)를 넘기는 것이 아닌, 작업이 완료되어야 결과를 넘겨주는 방식입니다. 결과가 나올 때까지 다른 작업을 수행할 수 있으므로 효율적인 자원의 이용이 가능합니다. 일반적으로 멀티 스레드를 사용한 처리 방식에 해당합니다.  <br/>  
동기란 요청과 결과가 한 자리에서 동시에 일어나는 방식입니다. 작업을 끝낼 때까지 제어권을 반납하지 않습니다. 즉, 노드 사이의 트랜잭션을 동시에 맞추는 것입니다. 작업이 길어지면 결과가 나올 때까지 다른 작업을 수행할 수 없다는 단점이 있습니다. 싱글 스레드 방식이 해당됩니다.
<br/>

#### 33. 트랜잭션transaction
> 하나의 논리적인 작업의 단위를 구성하는 연산의 집합을 말합니다. 질의를 묶어놓은 실행 단위라 할 수 있습니다. 작업의 완전성을 보장해줍니다.  <br/>
트랜잭션은 원자성, 일관성, 독립성, 지속성의 4가지 조건(ACID property)을 가지는데,  <br/>
원자성atomicity은 트랜잭션의 명령어가 모두 실행되거나, 모두 실패해야 한다는 것입니다. 즉, 중간 상태가 없도록 보장하는 것입니다.  <br/>
일관성consistency은 트랜잭션이 완료된 후의 DB 상태(결과값)는 일관성 있게 유지되어야 한다는 것입니다.  <br/>
고립성은isolation은 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못하게 하는 특성입니다 (연산 중 끼어들 수 없음).  <br/>
지속성durability은 트랜잭션이 완료되면, 시스템 장애가 회복되고 난 후에도 그 데이터를 복구할 수 있게 해야 함을 뜻합니다. 즉, 소프트웨어나 하드웨어가 고장이 나더라도 완료된 트랜잭션은 영구적으로 반영(보장)되어야 한다는 것입니다.
<br/>

#### 34. 교착상태
> 두 개 이상의 트랜잭션이 특정 자원의 잠금lock을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하는 것으로, 서로 상대방의 작업이 끝나기를 무한정 기다리는 상태를 말합니다.  <br/>
교착상태 발생에는 다음과 같은 네 가지 조건이 충족되어야 합니다.  <br/>
상호 배제Mutual Exclusion는 한 번에 한 개의 프로세스만이 공유 자원을 사용해야 한다는 것. 즉, 자원을 차지한 프로세스가 자신을 제외한 프로세스를 모두 배제하는 것입니다.  <br/>
점유 대기Hold and Wait는 프로세스가 이미 하나를 점유한 상태에서 다른 자원을 부가적으로 요구하는 것입니다.  <br/>
비선점No Preemption은 다른 프로세스의 자원을 강제로 가져올 수 없는 것입니다. 프로세스가 공유 자원을 가졌지만 해체되지 않는 상태를 말합니다.  <br/>
환형 대기Circular Wait는 프로세스와 자원들이 원형을 이룬 상태에서, 각 프로세스가 자신에게 할당된 자원을 가지며 다른 프로세스의 자원을 상호 요구하는 경우입니다.
<br/>

#### 35. 프로그램과 프로세스
> 프로그램은 어떤 작업을 위한 실행 파일(.exe)이고, 프로세스는 컴퓨터에서 실행되고 있는 프로그램을 말합니다. 즉, 메모리에 올라와 실행되고 있는 하나의 인스턴스라고 볼 수 있습니다.  <br/>
운영체제로부터 자원(CPU 시간, 주소 공간, 메모리 영역_code,data,heap,stack)을 할당받으며 process ID를 붙여 관리합니다. 각 프로세스는 별도의 주소 공간에서 실행되고, 서로에게 접근하려면 별도의 통신 기능(파이프, 파일, 소켓 등)을 이용해야 합니다.  <br/>
(자바에는 프로세스가 존재하지 않고 스레드만 존재)
<br/>

#### 36. 스레드Thread
> 프로세스가 할당받은 자원을 이용하는 실행 단위입니다. 한 프로세스 내에서 동시에 실행되어 code, data, heap 영역을 공유하지만, 독립적인 실행을 위해 레지스터와 stack 영역은 각각 할당받게 됩니다. 자바에선 JVM에 의해 관리됩니다.  <br/>
기본적으로 모든 프로세스는 하나의 메인 스레드를 가지고 있습니다. 자바의 main() 메소드가 하나의 스레드로 수행됩니다. 2개 이상의 스레드를 가진 멀티 스레드는 콘텍스트 스위칭을 스레드 단위로 실행하여 효율적인 자원 관리가 가능해집니다. 또한, 메모리를 공유해 스레드 간 데이터 전송이 간단해지고, 프로세스보다 전환 속도가 빠른 장점이 있습니다.  <br/>
자바에선 Thread를 상속받거나 Runnable 인터페이스를 implement하여 run() 메소드를 오버라이딩 하는 것으로 스레드를 만들 수 있습니다.  <br/>
스레드의 생명 주기는 먼저, 실행되기 전 준비단계인 준비Runnable 상태가 있습니다. CPU가 점유하지 않고 대기 중인 상태를 말합니다. start() 메소드를 실행하면 오버라이딩 된 run() 메소드에 설정된 스레드가 Runnable 상태로 진입합니다. Ready 상태라고도 말합니다.  <br/>
실행Running 상태는 CPU를 점유해 실행 중인 상태이며, JVM이 run() 메소드를 호출하여 진입합니다.  <br/>
종료Dead 상태는 스레드가 모두 실행되고 난 후 완료 상태를 말합니다. Done 상태라고도 합니다.  <br/>
지연Blocked 상태는 CPU 점유권을 상실한 상태로, sleep()이나 wait() 메소드에 의해 진입되며, nofity() 메소드가 호출되면 다시 Runnable 상태로 전환됩니다.
<br/>

#### 37. String, StringBuilder, StringBuffer
> String은 새로운 값을 할당할 때마다 새로 클래스에 대한 객체를 생성합니다. 즉, 값을 변경하면 heap에 새로운 객체가 만들어지게 됩니다. private final char[] 형태이기 때문에 불변객체의 형태를 띠고 있습니다. 따라서 String의 값을 변경하면 기존 주소 값이 스택에 쌓여 메모리 관리에 비효율적입니다.  <br/>  
문자열 연산이 빈번하게 발생하는 경우엔 가변성을 가지는 StringBuffer나 StringBuilder 클래스를 사용하는 것이 좋습니다. 두 클래스는 동일 객체 내에서 append()를 이용해 문자열을 변경할 수 있습니다.  <br/>
두 클래스의 차이점은 StringBuilder는 비동기 처리를 해 안정성thread-safe 에서는 떨어지지만, 속도가 빠르다는 특징이 있습니다. 즉, 단일 스레드이거나 동기화를 고려하지 않는 경우 사용합니다.  <br/>
반대로, StringBuffer는 동기 처리를 하므로 멀티 스레드 환경에서 안전합니다.
<br/>

#### 38. 스트링풀String Pool
> JVM이 string interning을 구현한 것으로, heap 영역에 저장됩니다. String interning이란 각각의 고유 스트링값(불변 객체)의 사본을 하나만 저장하는 메소드입니다. literal 방식으로 String을 생성하면 내부적으로 intern()을 호출하는데, 해당 literal이 pool에 있는지 확인하고 있으면 pool에 있는 literal을 반환합니다. 없으면 해당 literal을 pool에 집어넣습니다.
<br/>

#### 39. 커넥션풀, DAO, DTO
> 웹 서버는 DB와 연결하기 위해 매번 커넥션 객체를 생성하여 부하가 발생할 위험이 있는데, 이를 방지하기 위해 나온 것이 커넥션 풀입니다. DB에 접속하는 객체를 전용으로 하나만 만들고, 모든 페이지에서 그 객체를 호출해 사용하는 방식입니다. 하나의 pool에 미리 생성한 커넥션 객체들을 담아두고, 클라이언트 요청이 들어올 때마다 하나씩 빌려주고 돌려받게 됩니다.  <br/>  
DAO(Data Access Object)가 여기서 사용되는데, DAO란 DB 데이터 접근을 위한 트랜잭션 객체입니다. DB를 사용해 데이터를 조회/조작하는 기능을 전담하며, 비즈니스 로직과 분리할 수 있고, 효율적인 쿼리 접근이 가능합니다. 사용자는 자신이 필요한 인터페이스를 DAO에게 보내고, DAO는 이 인터페이스를 구현한 객체를 사용자에게 다시 반환합니다.  <br/>  
DTO(Data Transfer Object)란 DAO 클래스를 이용하여 DB에서 데이터를 관리할 때, 해당 데이터의 클래스를 만들어 매개채로 사용하는 것입니다. 즉, DAO에서 데이터를 주고받을 때 쓰이는 객체를 뜻합니다. 자바에서 getter/setter를 통해 구현됩니다.
<br/>

#### 40. 자바빈JavaBean
> JavaBean 규격서에 따라 작성된 자바 클래스를 말합니다. 뷰(표현부)와 로직(구현부)를 분리하여 작성함으로서 해석을 쉽게 하고 재사용성을 증가시킵니다. 여러 오브젝트들을 하나의 오브젝트에 담은 소프트웨어 프로토콜이라고 볼 수 있습니다.  <br/>
설계 규약에는 '멤버변수를 property라고 부른다', '프로퍼티의 접근제어자는 private이며 별도의 public get/set 메소드가 존재해야 한다', '생성자는 매개변수가 존재하지 않아야 한다' 등의 규격이 있습니다.
<br/>

#### 41. 래퍼 클래스Wrapper Class
> 8개의 기본 타입에 해당하는 데이터를 객체로 포장해 주는 클래스를 말합니다. 기본 자료형으로 표현된 데이터를 참조 자료형으로 만들어야 할 경우 사용합니다. 예를 들어, 메소드에서 참조형을 인자로 받는 경우, 객체 자료형으로 저장해야 할 경우, 객체 간 비교가 필요한 경우 등이 있습니다.  <br/>
JDK 1.5부터는 오토박싱과 언박싱으로 기본형과 래퍼클래스의 간단한 변형 방법을 지원하고 있습니다.
<br/>

#### 42. 예외 처리
> 예외 처리란 프로그램 실행 시 발생할 수 있는 예외에 대비하는 것으로, 프로그램의 비정상 종료를 막고 실행 상태를 유지하는 것입니다.  <br/>
체크 예외란 컴파일 단계에서 확인되는 예외들로, 명시적으로 처리해야 합니다.  <br/>
언체크 예외는 실행 단계에서 확인되는 예외들입니다. 명시적 처리를 강제하지 않으며, RuntimeException 클래스의 하위 클래스들이 속합니다.
<br/>

#### 43. 제네릭Generic
> 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법입니다. 선언 시 형식 매개 변수(주로 타입 변수 <T>)를 타입으로 넣고, 사용할 때 클래스(사용할 타입)를 지정합니다. 즉, 메소드나 클래스를 선언할 때는 구체적인 타입을 정하지 않고, 생성 시 원하는 자료 값을 넣어 사용하는 것입니다.  <br/>
컴파일할 때 타입을 체크해 에러를 사전에 잡을 수 있고, 컴파일러가 자동으로 타입 캐스팅을 해주며, 타입만 다르고 코드의 내용이 대부분 일치할 때 코드의 재사용성이 좋아진다는 장점이 있습니다.  <br/>
extends 키워드를 사용하면 좀 더 구체적인 타입 제한이 가능해집니다. ex)T extends Number는 Number 타입이나 그 하위 클래스만 올 수 있음.  <br/>
컴파일러에 의해 검사되어 타입 변환된 제네릭은 코드 내에서 제거되며, 컴파일된 클래스 파일에는 어떠한 제네릭 타입도 포함되지 않게 됩니다. 이는 제네릭을 사용하지 않는 코드와의 호환성을 유지하기 위함입니다.
<br/>

#### 44. 프레임워크Framework
> 애플리케이션을 개발할 때 공통적인 부분을 제공하는 클래스와 인터페이스의 집합입니다. 기본이 되는 뼈대를 통해 다양한 형태의 결과물을 만들 수 있도록 돕는 역할을 합니다. 애플리케이션 코드는 프레임워크가 짜놓은 틀에서 수동적으로 동작하며, 이로 인해 통합성과 일관성이 보장됩니다.  <br/>  
+) 제어의 역전 : 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경 써야 할 것을 줄이는 전략.  <br/>
제어를 역전시키는 접근 방법 중 대표적인 것에는 프레임워크의 event, delegate에 사용자의 메소드를 등록시키는 것. 프레임워크는 등록된 메소드를 감지하여 실행.  <br/>
또 다른 방법은 프레임워크에 정의되어 있는 인터페이스, 추상메소드를 상속해 프레임워크에 넘겨주는 것입니다. 이것을 의존 주입Dependency Injection이라고 합니다.
<br/>

#### 45. 라이브러리Library
> 소프트웨어 개발을 돕는 도구의 모음입니다. 개발자가 필요한 라이브러리만을 호출하는 형태이므로 프레임워크보다 유연성을 갖고 있습니다.  <br/> 
프레임워크와의 차이점은 제어 흐름에 대한 주도성입니다. 프레임워크는 주도성을 스스로가 가지며 사용자가 그 구조에 맞춰나가지만, 라이브러리는 사용자가 흐름을 주도하고 필요할 때만 가져다 쓰는 형태입니다.
<br/>

#### 46. Java Collections Framework
> 객체를 저장하도록 설계된 프레임워크로, 데이터를 쉽게 처리/연산할 수 있는 표준화된 방법을 제공하는 객체의 집합입니다.  <br/>  
먼저, List는 순서가 있는 데이터의 집합입니다. 데이터의 중복이 가능하고, 인덱스를 통해 조회할 수 있습니다.  <br/>
List 중 ArrayList는 연결리스트와 배열이 합쳐진 형태로 index를 통해 데이터를 순차적으로 저장합니다. 따라서 다이렉트 접근이 가능해 검색에 매우 효율적입니다. 기존 배열과 다르게 연산을 통해 크기를 늘릴 수 있다는 장점이 있습니다.  <br/>
대부분의 컬렉션이 List를 상속받고, ArrayList도 같은 형태이므로 저장은 List 객체에 하고 사용 시 다운 캐스팅 처리하면 유지 보수에 용이합니다.  <br/>  
LinkedList는 양방향 포인터 구조로, 데이터의 삽입, 삭제 시 해당 노드의 주소지만 바꾸면 되어 삽입, 삭제가 빈번한 데이터에 적합합니다. 단, 검색 시 처음부터 노드를 순회해야 하므로 검색에는 부적합합니다.  <br/>  
Set은 저장 순서를 유지하지 않는 집합의 개념으로, 중복 포함이 불가능합니다. 인덱스로 객체를 관리하지 않기 때문에 iterator를 통해 데이터에 접근합니다.  <br/>  
먼저, HashSet은 내부적으로 HashMap 인스턴스를 이용하여 요소를 저장합니다. 해시 알고리즘을 사용하여 속도가 매우 빠르다는 장점이 있습니다. null 객체나 동일 타입 오브젝트 저장을 허용합니다.  <br/>  
LinkedHashSet은 저장 순서를 유지하는 HashSet이라 볼 수 있습니다. 입력된 순서대로 데이터를 관리하게 됩니다.  <br/>
해시 함수를 사용할 때, hash는 고정값을 가지므로 중복이 발생할 수 있는데, 이를 '해시 충돌'이라 합니다. 이때 동일한 해시값을 LinkedList로 저장하여 기존에 저장되어있는 값과 연결해 순서를 유지합니다. 즉, entry 내에 before/after entry가 저장된 형태를 가집니다.  <br/>
여기서 해시 함수란 어떤 가변 값의 key를 input으로 해시함수에 넣으면 output으로 고정된 hash 값이 나오는 것을 말합니다.  <br/>  
TreeSet은 내부적으로 tree 형태를 사용하며, 삽입/삭제 연산 시 재정렬 과정이 필요하므로 다소 느린 속도를 가집니다. null을 허용하지 않고, 기본적으로 오름차순 자동 정렬되나 comparator를 구현하면 정렬 기준을 지정할 수 있습니다.  <br/>  
Map은 List, Set과 다르게 collection 인터페이스를 상속받지 않습니다. 순서가 유지되진 않지만, 데이터를 삽입할 때 key, value가 쌍을 이루어 저장되므로 검색에 유리합니다. key는 중복이 불가하지만, value는 중복을 허용합니다.  <br/>  
HashMap은 Entry<K,V> 배열로 저장되며, 인덱스는 내부 해시 함수가 계산합니다. 따라서 내부 hash 값에 따라 키 순서가 정해지므로 특정 규칙 없이 출력됩니다. iterator를 사용해야 하고, 기본적으로 동기 처리를 지원하지 않습니다.  <br/>  
LinkedHashMap은 HashMap을 상속받으며, 배열이 아닌 LinkedList로 저장된다는 차이가 있습니다. 삽입 순서가 유지되는데 이를 위해 포인터값을 저장하므로 HashMap보다 약간 느린 속도를 가집니다. 비동기 처리되며, key 값으로 최대 한 개의 null을 허용하고, value 값으로 복수 null을 허용한다는 점은 HashMap과 같습니다.  <br/>  
TreeMap은 TreeSet과 유사한 클래스입니다. 차이점은 키와 값이 저장된 Map.Entry를 저장한다는 점, TreeSet과 달리 중복 객체가 허용된다는 것 입니다.  <br/>  
HashTable은 Map 인터페이스를 구현한 클래스로, 중복을 허용하지 않습니다. 싱글 락lock을 지원하고, 모든 메소드를 동기화 처리하므로 멀티스레드 환경에서 안전합니다. 단, 동기화 과정으로 인해 HashMap보다 약간 느린 속도를 가집니다. enumerator를 사용하며 null을 허용하지 않습니다.  <br/>  ConcurrentHashMap은 HashTable의 대안으로, 멀티플 락을 지원합니다. HashTable이나 synchronizedMap은 map 전체에 락을 걸지만, ConcurrentHashMap은 map 일부에만 락을 걸 수 있어 업데이트 동작이 일어나는 동안 오직 그 부분에만 락을 수행합니다.
<br/>

#### 47. Iterator
> 컬렉션 클래스에 저장된 요소들을 나열하는 방법을 제공합니다. 컬렉션 클래스의 iterator()를 호출해 구현한 객체를 얻어 사용합니다. hasNext()를 통해 읽어 올 요소가 남아있는지 확인하고, next()로 다음 요소를 읽어오는 방식입니다.
<br/>

#### 48. Array와 List의 차이
> Array는 선언 시 크기 지정이 필요하고, 할당은 기본 타입과 오브젝트 모두 가능합니다. 객체를 넣을 때 인덱스 번호를 정의하여 검색 및 접근을 빠르게 할 수 있습니다.  <br/>
List는 사이즈를 동적으로 변화시킬 수 있고, 별도의 인덱스 지정이 필요하지 않습니다. 다차원 저장이 불가하며, 배열보다 추가/삭제에 유리합니다. 할당 타입은 오브젝트만 가능한데, 기본 데이터 타입은 JVM에 의해 자동으로 오브젝트화 되어 할당됩니다.
<br/>

#### 49. 스택, 큐, 힙, 트리, 그래프
> 스택stack이란 임시 변수를 저장하는 메모리 영역입니다. 후입선출LIFO 구조이며, 지역 변수의 성향을 가집니다. 함수가 새 변수를 선언하면 스택에 push되고, 함수가 종료되면 해당 함수에 의해 푸시 된 모든 변수가 해제(삭제)되기 때문입니다. 사용자가 할당/해제하지 않아도 되고, CPU에 의해 관리되어 속도가 매우 빠릅니다. 저장할 수 있는 변수 크기에 제한이 있습니다.  <br/>  
힙heap은 완전 이진 트리의 일종으로 우선순위 큐를 위해 만들어진 자료구조이고, 최댓값/최솟값을 빠르게 찾아낼 수 있습니다. 힙을 저장하는 표준적인 자료구조는 배열입니다.  <br/>  
힙에 작성한 메모리는 모든 함수에서 접근이 가능하기 때문에 전역 변수의 성향을 가집니다. 따라서 긴 생명주기를 가지는 데이터들이 저장됩니다. static 전역 변수는 JVM 실행 시부터 클래스 메모리에, 일반 오브젝트 타입은 new 키워드로 동적 생성될 때 heap에 할당됩니다. 힙 영역에 있는 오브젝트를 가리키는 레퍼런스 변수가 스택에 올라갑니다.  <br/>  
스택과 달리 단 하나의 힙 영역만 존재하며, 스택보다 자유로워 크기, 요구/횟수 순서 규칙 제한이 없지만, 포인터를 사용해 메모리에 엑세스하므로 속도가 상대적으로 느립니다.  <br/>  
큐queue는 선입선출FIFO 구조로, 우선순위가 같은 작업에 사용됩니다.  <br/>  
트리tree는 노드로 이루어진 구조입니다. 하나의 루트 노드는 자식 노드를 가지고 있고, 이렇게 반복된 구조가 트리의 형태를 띠게 됩니다. 즉, 노드node들과 노드들을 연결하는 간선edge들로 구성되어 있습니다. 비선형 자료구조로 계층적 관계를 표현합니다. 그래프의 한 종류라 볼 수 있습니다.  <br/>  
그래프graph는 노드와 간선을 모아 놓은 자료 구조입니다. 연결되어 있는 객체 간의 관게를 표현할 수 있습니다. 트리와의 차이는 루트 노드나 부모-자식 관계의 개념이 없습니다. 
<br/>

#### 50. 자바 리플랙션Reflection
> 이미 로딩이 완료된 클래스에서 또 다른 클래스를 동적으로 로딩Dynamic Loading 하여 클래스의 정보를 추출하는 기법입니다. 런타임 시간에 이루어지며, 구체적인 클래스 타입을 알지 못해도 해당 클래스의 변수, 생성자, 메소드 등을 얻을 수 있습니다.  <br/>
자바 클래스 파일은 바이트 코드로 컴파일되어 static 영역에 위치하기 때문에 클래스 이름을 통해 정보를 찾아낼 수 있는 것입니다.
<br/>

#### 51. 자바 박싱boxing과 언박싱unboxing
> 박싱은 기본형primitive 객체를 Wrapper Class 객체로 만드는 것입니다. new 연산자를 통해 생성하거나, 기본형에서 valueOf() 메소드를 이용해 변환합니다.  <br/>  
언박싱은 박싱과 반대로 Wrapper Class 객체을 기본형으로 바꾸는 것입니다. 기본자료형Value() 메소드를 사용해 변환합니다.  <br/>  
JDK 1.5부터는 오토 박싱auto boxing과 오토 언박싱auto un-boxing이 지원됩니다. 해당 래퍼 클래스에 기본 자료형의 데이터를 대입하거나, 기본 자료형에 래퍼 객체를 대입하면 컴파일러가 자동으로 변환해줍니다.
<br/>

#### 52. 자바 가변인자Varargs
> 가변 인자 메서드Variable Arity Method.  <br/>
매개변수의 개수를 동적으로 지정해 주는 기능입니다. 지정된 자료형의 인자를 여러 개 받을 수 있고, 내부적으로 배열을 생성해 처리됩니다. 키워드 ...을 통해 '타입... 변수명'으로 사용하며, 가변인자 외의 매개변수가 있다면 가변인자는 마지막에 선언해야 합니다. 주의할 점은, 컴파일 에러를 방지하기 위해 가변인자 메소드 오버로딩을 하지 않는 것을 권장합니다.
<br/>

#### 53. 모듈Module과 컴포넌트Component
> 모듈이란 가장 상위에 위치한 구현의 단위로, 실질적으로 구현 된 개체를 말합니다. 독립적으로 하나의 역할(책임)을 수행하며, 계층 구조에서 한 부분을 차지합니다.  <br/>  
컴포넌트란 각각 독립된 모듈로, 런타임 개체를 참조합니다. 즉, 실질적으로 동작하는 엔티티를 말합니다. 재사용이 가능한 최소 단위의 역할을 수행합니다. 하나의 컴포넌트는 1개 이상의 클래스로 작성될 수 있으며, 인터페이스를 통해 접근해야 합니다.  <br/>  
모듈과 컴포넌트는 혼동될 수 있으나, 모듈이 특정 기능을 온전히 수행할 수 있도록 만들어졌다면, 컴포넌트는 그 모듈 내에서도 재사용이 가능한 단위라 할 수 있습니다.  <br/>  
예를 들어, 서버-클라이언트 구조에서 하나의 서버가 50개의 클라이언트에게 서비스를 제공한다면,  <br/>
구현된 모듈 = 서버 1개 + 서비스가 구현한 모듈 1개 = 2개,  <br/>
동작하는 컴포넌트 = 서버 1개 + 클라이언트 50개 = 51개.
<br/>
